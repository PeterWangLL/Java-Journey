# Index Condition Pushdown

本节介绍索引下推这一概念，MySQL5.6正式推出，用于减少回表次数。

首先我们先介绍在推出索引下推这一特性前，MySQL查询的执行逻辑，先简单了解一下MySQL的基础架构，包括Server层和存储引擎，Server有连接器、分析器、优化器、执行器，关于MySQL的执行过程和架构后面会详细讲，这里只做简单介绍。

下面假设有一张表，两个字段name和age，以name和age字段建立联合索引，执行一条select语句，select \* from table where name=peter and age = 20，执行过程走到执行器，在5.6之前，它会把where name=peter打到存储引擎，然后存储引擎根据这一条件查到所有满足的数据并返回给执行器，接着执行器再根据age=20条件将满足的结果筛选出来，于是你会有这样的疑问？为什么不能把两个条件都传给存储引擎呢？（MySQL有多个存储引擎可以选择，默认是InnoDB）

索引下推就是这样干的，但是要满足条件：联合索引才能下推，老规矩我们还是从InnoDB底层B+树讲起，建立联合索引时，key域存储了该联合索引的字段，那么执行器将name和age两个字段传给InnoDB的话，age也能在匹配索引时被用到，于是查到的data域自然就大大减少了，那么回表次数就较少了，同时存储引擎到Server层到数据传输量也减少了。

下面假设name和age字段分别为普通索引，那么就无法使用索引下推了，还是从索引底层讲起，建立B+树时分别以name和age建立了两棵树，那么以name为条件匹配时，自然就用不上age了，所以将age下推至InnoDB无法起作用。

好了，现在可以总结：只有使用联合索引时，索引才可以下推至存储引擎，因为B+树的key域存储了下推的条件字段，才可以用来减少data域查询的结果，反之，当B+树的key域没有对应字段时，下推该字段派不上用场。

另外，当索引无法下推时，执行器会以优化器判断得出的最优索引来作为条件得到全量数据，如果都没有命中索引则以第一个字段作为条件，之后再根据剩下的条件筛选出符合的数据。
